#!/usr/bin/env python

""" Parser for XML generated by the Compiler Analysis pass.

    This module contains classes to represent different parts of the program:
      A file contains a set of functions.
      A function contain a body.
      A body contains a set of code blocks and a set of loops, each guarded by a set of conditionals.
      A code block contains a set of flops, and a set of scalar and array accesses.
      A loop contains a body.
    Each class supports the "collect" traversal routine that aids in traversing the code tree.
"""
__author__ = "Cy Chan"
__copyright__ = "Copyright 2016, The Regents of the University of California, through Lawrence Berkeley National Laboratory"
__credits__ = ["Cy Chan"]
__license__ = "Modified BSD License (see LICENSE file)"
__version__ = "2.0"
__maintainer__ = "Cy Chan"
__email__ = "cychan@lbl.gov"
__status__ = "Production"

import xml.dom.minidom
import ast
import operator
import copy
import re
from sympy.parsing.sympy_parser import parse_expr

from box import Box
from collection import Collection
from common import options, collapse, numIters, rangeMerge, rangeDisjoint

# TODO: load these from application-specific XML file
textsubs = [('level\s*-\s*1' , 'levelm1'),
            ('level\s*\+\s*1' , 'levelp1'),
            ('\s*\.\s*' , '__dot__'  ),
            ('\s*->\s*', '__arrow__'),
            ('\s*\[\s*', '__lbrkt__'),
            ('\s*\]\s*', '__rbrkt__'),
            ('\s*\]\s*', '__rbrkt__'),
           ]

def dprint(s):
  if options.flag_verbose_parser:
    print s

def to_sym_dict(list_of_pairs):
  return dict(map(lambda (x,y): (parse_expr(x), parse_expr(y)), list_of_pairs))

# direct text replacement using string replace
def doTextRepl(s, textsubs):
  for sub in textsubs:
    s = re.sub(sub[0], sub[1], s)
  return s

# symbolic replacement using sympy xreplace
def doSymRepl(expr, repl):
  if type(expr) == type('') or type(expr) == unicode:
    expr = parse_expr(expr)
  return expr.xreplace(repl)

def parseExpr(s, symsubs):
  s = doTextRepl(s, textsubs)
  try:
    return int(s) # try to do the fast thing first
  except ValueError as e:
    return doSymRepl(s, symsubs)

def parseTuple(s, f = lambda x: x):
  """Parses a string containing a tuple.
    
     Returns a tuple of elements with f applied to each element.
     Returns a tuple of strings by default."""
  s = s.strip('() ').split(',') # remove enclosing parens and whitespace and split on commas
  return tuple(map(lambda x: f(x.strip()), s)) # strip whitespace and cast to tuple of ints

def subToInt(x, params):
  if type(x) == int:
    result = x
  else:
    try:
      result = int(doSymRepl(x, params))
    except Exception as e:
      print "Could not do integer parameter substitution for expression: ", x
      print "Parameters available: ", params
      raise e
  return result

def arrayName(name, component, namesubs):
  if component != '':
    component = parse_expr(component).subs(namesubs)
    return '%s.%s' % (name, component)
  else:
    return name

def makeName(node, namesubs):
  return arrayName(str(node.getAttribute('name')), \
                   str(node.getAttribute('component')), namesubs)

def getChildren(node, tag):
  return filter(lambda x: x.nodeName == tag, node.childNodes)


class Flops(object):
  slots = ['adds', 'multiplies', 'divides', 'specials']
  def __init__(self, node):
    for x in self.slots:
      self.__setattr__(x, int(node.getAttribute(x)))
    dprint(self)
  def __str__(self):
    return "Flops(%d, %d, %d, %d)" % \
           tuple(map(lambda x: self.__getattribute__(x), self.slots))


class Scalar(object):
  slots = ['name', 'type', 'const', 'reads', 'writes']
  def __init__(self, node):
    self.name = str(node.getAttribute('name'))
    self.type = str(node.getAttribute('datatype'))
    self.const = str(node.getAttribute('isConstant'))
    self.reads = int(node.getAttribute('reads'))
    self.writes = int(node.getAttribute('writes'))
    dprint(self)
  def __str__(self):
    return "%s %s, R=%d, W=%d" % (self.type, self.name, self.reads, self.writes)


class ArrayAccess(object):
  slots = ['index', 'loopvars', 'reads', 'writes']
  def __init__(self, node=None, env=None, index=None, loopvars=None, reads=None, writes=None):
    if node:
      self.index = parseTuple(node.getAttribute('offset'), lambda x: parseExpr(x, env['symsubs']))
      self.loopvars = parseTuple(node.getAttribute('dependentloopvar'), str)
      self.reads = int(node.getAttribute('reads' ))
      self.writes = int(node.getAttribute('writes'))
      dprint(self)
    else:
      # this constructor is used in analyze.WorkingSet.loop() to represent an index set
      self.index = index
      self.loopvars = loopvars
      self.reads = reads
      self.writes = writes
  def __str__(self):
    idxStr = '('+','.join(map(str, self.index))+')'
    lvStr = '('+','.join(self.loopvars)+')'
    return "  %s+%s, R=%d, W=%d" % \
           (idxStr, lvStr, self.reads, self.writes)
  def __sub__(self, other):
    assert self.loopvars == other.loopvars
    boxDiff = Box(intervals = self.index) - Box(intervals = other.index)
    return map(lambda x: x.intervals, boxDiff.contents)
  def isStateVar(self):
    return all(map(lambda x: x == '', self.loopvars))
  def subParams(self, params):
    result = ArrayAccess()
    result.index = tuple(map(lambda x: subToInt(x, params), self.index))
    result.loopvars = self.loopvars
    result.reads = self.reads
    result.writes = self.writes
    return result


class Array(object):
  slots = ['name', 'type', 'accesses']
  def __init__(self, node = None, env = None):
    if node:
      self.name = makeName(node, env['namesubs'])
      self.type = str(node.getAttribute('datatype'))
      dprint(self)
      self.accesses = map(lambda x: ArrayAccess(x, env), getChildren(node, 'access'))
  def __str__(self):
    return "%s %s" % (self.type, self.name)
  def onlyStateVars(self):
    return all(map(ArrayAccess.isStateVar, self.accesses))
  def subParams(self, params):
    result = Array()
    result.name = self.name
    result.type = self.type
    result.accesses = map(lambda x: x.subParams(params), self.accesses)
    return result


class CodeBlock(object):
  """Branchless section of code with conditions for execution.

     Contains arithmetic, scalar and array accesses, and communication."""
  slots = ['flops', 'scalars', 'arrays', 'conds']
  def __init__(self, node = None, conds = [], env = None):
    if node:
      if node.getAttribute('adds'):
        self.flops = Flops(node)
      else:
        print "WARNING: No Flops attributes on code block!"
      self.conds = conds
      dprint(self)
      self.scalars = map(Scalar, getChildren(node, 'scalar'))
      self.arrays = map(lambda x: Array(x, env), getChildren(node, 'array'))
  def __str__(self):
    return "Code Block (%s):" % str(map(str, self.conds))
  def collect(self, f):
    return Collection(colls = [f(self.flops, self.conds)] + \
                              map(lambda s: f(s, self.conds), self.scalars) + \
                              map(lambda a: f(a, self.conds), self.arrays))
  def subParams(self, params):
    result = CodeBlock()
    result.flops = self.flops
    result.scalars = self.scalars
    result.arrays = map(lambda x: x.subParams(params), self.arrays)
    result.conds = self.conds
    return result


class Conditional(object):
  """Encapsulates a conditional."""
  slots = ['linenum', 'condition', 'when']
  def __init__(self, node):
    assert node.nodeName == 'if' or node.nodeName == 'else'
    tag = 'linenum' if node.nodeName == 'if' else 'iflinenum'
    self.linenum = int(node.getAttribute(tag))
    self.condition = str(node.getAttribute('conditional'))
    self.when = (node.nodeName == 'if')
    if options.flag_verbose_conditionals:
      print "Found", str(self)
  def __str__(self):
    return "Conditional: " + str((self.linenum, self.condition, self.when))


class Body(object):
  """A function or loop body: contains information on enclosed code blocks and loops."""
  slots = ['codeblocks', 'loops']
  def __init__(self, node = None, conds = [], env = None):

    """Does recursive traversal of conditional blocks within body."""
    def traverse(node, tag, conds):
      """Traverse nested if/else blocks in the body of a function or loop."""
      if tag:
        result = map(lambda x: (x, conds, env), getChildren(node, tag))
      else:
        result = [(node, conds, env)]
      for cnode in getChildren(node, 'if') + getChildren(node, 'else'):
        c2 = conds + [Conditional(cnode)]
        result.extend(traverse(cnode, tag, c2))
      return result

    def sort_key(elt):
      (n,c,s) = elt
      # TODO: add linenum to function nodes in XML
      if n.nodeName == 'function':
        return 0
      # TODO: add linenum to else nodes in XML
      if n.nodeName == 'else':
        attr_key = 'iflinenum'
      else:
        attr_key = 'linenum'
      return int(n.getAttribute(attr_key))

    if node:
      self.codeblocks = map(lambda x: CodeBlock(*x), sorted(traverse(node, None, conds), key=sort_key))
      self.loops = map(lambda x: Loop(*x), sorted(traverse(node, 'loop', conds), key=sort_key))

  def collect(self, f):
    return Collection(colls = map(lambda x: x.collect(f), self.codeblocks) + \
                              map(lambda x: x.collect(f), self.loops))
  def subParams(self, params):
    result = Body()
    result.codeblocks = map(lambda x: x.subParams(params), self.codeblocks)
    result.loops = map(lambda x: x.subParams(params), self.loops)
    return result


class Loop(object):
  """Contains information on loop variables, bounds, strides, and loop body."""
  slots = ['name', 'loopvar', 'linenum', 'range', 'stride', 'conds', 'body']
  def __init__(self, node = None, conds = [], env = None):
    if node:
      self.loopvar = str(node.getAttribute('loopvar'))
      self.linenum = int(node.getAttribute('linenum'))
      self.range = (parseExpr(str(node.getAttribute('lowerbound')), env['symsubs']),
                    parseExpr(str(node.getAttribute('upperbound')), env['symsubs']))
      self.stride = int(node.getAttribute('stride'))
      self.conds = conds
      dprint(self)
      self.body = Body(node, conds, env)
  def __str__(self):
    return "Loop %d: %s = [%s, %s] / %d, %s" % \
           (self.linenum, self.loopvar,
            self.range[0], self.range[1], self.stride, str(map(str, self.conds)))
  def iter_n(self):
    return numIters(self.range) / self.stride
  def collect(self, f):
    return self.body.collect(f).loop(self)
  def copy(self, new_range = None):
    result = Loop()
    result.loopvar = self.loopvar
    result.linenum = self.linenum
    result.range = new_range if new_range else self.range
    result.stride = self.stride
    result.conds = self.conds
    result.body = self.body
    return result
  def blocked(self, block_params):
    for (orig_range, blocked_range) in block_params.items():
      # check to see if loop matches the orig_range params
      if (type(self.range[0]) != int and \
          type(self.range[1]) != int and \
          self.range[0].has(orig_range[0]) and \
          self.range[1].has(orig_range[1])) or \
         (self.range[0] == 0 and \
          type(self.range[1]) != int and \
          self.range[1].has(orig_range[1] - orig_range[0])):
        return self.copy(blocked_range)
    return self
  def subParams(self, params, shallow = False):
    new_range = tuple(map(lambda x: subToInt(x, params), self.range))
    result = self.copy(new_range)
    if not shallow:
      result.body = self.body.subParams(params)
    return result


class Function(object):
  """Contains information on passed parameters and function body."""
  slots = ['name', 'params', 'local', 'body']
  def __init__(self, node, env):
    if node:
      self.name = str(node.getAttribute('name'))
      dprint("Parsing function %s ..." % self.name)
      self.params = map(lambda x: makeName(x, env['namesubs']), getChildren(node, 'nonlocal'))
      self.local = map(lambda x: makeName(x, env['namesubs']), getChildren(node, 'local'))
      self.body = Body(node, env = env)
  def collect(self, f):
    return self.body.collect(f)


class XMLParser(object):
  """Contains information on enclosed modules."""
  slots = ['doc', 'functions']
  def __init__(self, filename, symsubs, namesubs):
    if not filename or type(filename) != type(''):
      print "Invalid xml filename: %s" % filename
      raise Exception()
    try:
      self.doc = xml.dom.minidom.parse(filename)
    except Exception as e:
      print "Invalid xml: %s" % filename
      raise e
    env = {'symsubs' : symsubs, 'namesubs' : namesubs}
    program = getChildren(self.doc, 'program')[0]
    self.functions = map(lambda x: Function(x, env),
                         getChildren(program, 'function'))


class KeyValXMLParser(object):
  __slots__  = ['doc', 'items']
  def __init__(self, filename, val_type=str):
    self.items = []
    if filename:
      assert type(filename) == type('')
      self.doc = xml.dom.minidom.parse(filename)
      self.parse_items(val_type)
  def parse_items(self, val_type):
    self.items = []
    machine = self.doc.firstChild
    for prop in getChildren(machine, 'prop'):
      key = str(prop.getAttribute('key'))
      value = val_type(prop.getAttribute('val'))
      self.items.append((key, value))

# parser for XML generated by Polly-ExaSAT Scop Analysis

class PollyArray(object):
  """Contains information about an array."""
  __slots__ = ['name', 'elt_type', 'elt_size', 'dim_n', 'dims']
  def __init__(self, node):
    self.name = str(node.getAttribute('name'))
    assert self.name[0:7] == 'MemRef_'
    self.name = self.name[7:]
    self.elt_type = str(node.getAttribute('elt_type'))
    self.elt_size = int(node.getAttribute('elt_size'))
    self.dim_n = int(node.getAttribute('dim_n'))
    self.dims = []
    for (i, dnode) in enumerate(getChildren(node, 'dim')):
      assert dnode.getAttribute('index') == str(i)
      dim = str(dnode.getAttribute('size')).lstrip('%')
      self.dims.append(dim)
    if self.dim_n == 0:
      dprint("  Parsing scalar (%s, %s, %s) ..." % \
        (self.name, self.elt_type, self.elt_size))
    else:
      dprint("  Parsing array (%s, %s, %s, %s, %s) ..." % \
        (self.name, self.elt_type, self.elt_size, self.dim_n, self.dims))

class PollyAccess(object):
  """Contains information about a statement."""
  __slots__ = ['type', 'reduction_type', 'is_scalar', 'relation']
  def __init__(self, node):
    self.type = str(node.getAttribute('type'))
    self.reduction_type = str(node.getAttribute('reduction_type'))
    self.is_scalar = str(node.getAttribute('is_scalar'))
    self.relation = str(node.getAttribute('relation'))
    dprint("    Parsing access (%s, %s, %s, %s) ..." % \
      (self.type, self.reduction_type, self.is_scalar, self.relation))

class PollyStatement(object):
  """Contains information about a statement."""
  __slots__ = ['name', 'domain', 'schedule', 'accesses']
  def __init__(self, node):
    self.name = str(node.getAttribute('name'))
    self.domain = str(node.getAttribute('domain'))
    self.schedule = str(node.getAttribute('schedule'))
    dprint("  Parsing statement (%s, %s, %s) ..." % \
      (self.name, self.domain, self.schedule))
    self.accesses = map(PollyAccess, getChildren(node, 'access'))

class PollyScop(object):
  """Contains information about a scop region."""
  __slots__ = ['filename', 'linenum', 'function', 'region', 'depth', 'arrays', 'statements']
  def __init__(self, node):
    self.filename = str(node.getAttribute('filename'))
    self.linenum = str(node.getAttribute('linenum'))
    self.function = str(node.getAttribute('function'))
    self.region = str(node.getAttribute('region'))
    self.depth = str(node.getAttribute('max_loop_depth'))
    dprint("Parsing scop (%s, %s, %s, %s, %s) ..." % \
      (self.filename, self.linenum, self.function, self.region, self.depth))
    self.arrays = map(PollyArray, getChildren(node, 'array'))
    self.statements = map(PollyStatement, getChildren(node, 'statement'))

class PollyXMLParser(object):
  """Contains information produced by Polly-ExaSAT Scop Analysis."""
  __slots__ = ['doc', 'scops']
  def __init__(self, filename):
    assert type(filename) == type('')
    self.doc = xml.dom.minidom.parse(filename)
    program = getChildren(self.doc, 'program')[0]
    self.scops = map(PollyScop, getChildren(program, 'scop'))
